// Package server implements the gRPC service handlers for RequestDistributionGenerator.
package server

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"strings"
	"sync"

	pb "ig-wva/gen/go/request_distribution"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/encoding/protojson"
)

// CoreLogicHandler holds the current dataset configuration and distribution.
// It implements the pb.RequestDistributionGeneratorServer interface.
type CoreLogicHandler struct {
	pb.UnimplementedRequestDistributionGeneratorServer              // Embed for forward compatibility
	mu                                                 sync.RWMutex // Protects access to currentConfig and currentDistribution

	// Current state
	currentConfig       *pb.UpdateDatasetAndRatesRequest
	currentRequestTypes []*pb.RequestType
	currentDistribution []*pb.RateDistributionEntry
	hfToken             string
	pythonScriptPath    string
}

// PythonScriptOutput is used to unmarshal the output from the python script.
type PythonScriptOutput struct {
	RequestTypes     []RequestTypeEntry      `json:"request_types"`
	RateDistribution []RateDistributionEntry `json:"rate_distribution"`
}

// RequestTypeEntry is used to unmarshal the request types from the python script.
type RequestTypeEntry struct {
	ID               string  `json:"id"`
	LatencySloTpotMs float32 `json:"latency_slo_tpot_ms"`
	InputSizeBucket  string  `json:"input_size_bucket"`
	OutputSizeBucket string  `json:"output_size_bucket"`
}

// RateDistributionEntry is used to unmarshal the rate distribution from the python script.
type RateDistributionEntry struct {
	ID   string  `json:"id"`
	Rate float32 `json:"rate"`
}

// NewCoreLogicHandler creates a new CoreLogicHandler.
func NewCoreLogicHandler() *CoreLogicHandler {
	return &CoreLogicHandler{
		currentRequestTypes: make([]*pb.RequestType, 0),
		currentDistribution: make([]*pb.RateDistributionEntry, 0),
		pythonScriptPath:    "./process_dataset.py",
	}
}

// getPowerOfTwoBucket is a placeholder, mirroring Python logic.
func getPowerOfTwoBucket(n int) string {
	if n <= 1 {
		return "0-1"
	}
	k := 0
	for p := 1; p <= n; p *= 2 {
		k++
	}
	k-- // Corrected loop to find floor(log2(n))
	lowerBound := 1 << k
	upperBound := (1 << (k + 1)) - 1
	return fmt.Sprintf("%d-%d", lowerBound, upperBound)
}

// SetHfToken sets the Hugging Face token.
func (h *CoreLogicHandler) SetHfToken(token string) {
	h.mu.Lock()
	defer h.mu.Unlock()
	h.hfToken = token
}

func (h *CoreLogicHandler) processDatasetWithPythonScript(req *pb.UpdateDatasetAndRatesRequest) ([]*pb.RequestType, []*pb.RateDistributionEntry, error) {
	fmt.Println("Processing datasets with python script...")

	// Serialize the list of dataset requests to a JSON string
	var datasetRequestsJSON []string
	for _, datasetRequest := range req.GetDatasetRequests() {
		marshaled, err := protojson.MarshalOptions{UseProtoNames: true}.Marshal(datasetRequest) // Use UseProtoNames option
		if err != nil {
			return nil, nil, fmt.Errorf("failed to marshal dataset request to JSON: %w", err)
		}
		datasetRequestsJSON = append(datasetRequestsJSON, string(marshaled))
	}
	datasetRequestsJSONString := fmt.Sprintf("[%s]", strings.Join(datasetRequestsJSON, ","))

	tempOutputFile := "temp_config_output.json"
	args := []string{
		h.pythonScriptPath,
		"--dataset_requests", datasetRequestsJSONString, // Pass the JSON string
		"--output_file", tempOutputFile,
	}
	if h.hfToken != "" {
		args = append(args, "--hf_token", h.hfToken)
	}

	cmd := exec.Command("python3", args...)
	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	err := cmd.Run()
	if err != nil {
		fmt.Printf("Error executing python script: %v\n", err)
		fmt.Printf("Python script stderr: %s\n", stderr.String())
		return nil, nil, fmt.Errorf("failed to execute python script: %w", err)
	}

	stdoutString := stdout.String()
	fmt.Printf("Python script stdout: %s\n", stdoutString)

	if strings.Contains(stdoutString, "Warning: No valid prompt-response pairs found") || strings.Contains(stdoutString, "No configuration was generated.") {
		fmt.Println("Info: No data was generated by the script.")
		return []*pb.RequestType{}, []*pb.RateDistributionEntry{}, nil
	}

	fileContent, err := os.ReadFile(tempOutputFile)
	if err != nil {
		fmt.Printf("Error reading output file: %v\n", err)
		return nil, nil, fmt.Errorf("failed to read output file: %w", err)
	}

	var pythonOutput PythonScriptOutput
	err = json.Unmarshal(fileContent, &pythonOutput)
	if err != nil {
		fmt.Printf("Error unmarshalling JSON: %v\n", err)
		return nil, nil, fmt.Errorf("failed to unmarshal JSON: %w", err)
	}

	err = os.Remove(tempOutputFile)
	if err != nil {
		fmt.Printf("Error removing temp file: %v\n", err)
		// This is not a fatal error for the processing itself
	}

	requestTypes := make([]*pb.RequestType, len(pythonOutput.RequestTypes))
	for i, entry := range pythonOutput.RequestTypes {
		requestTypes[i] = &pb.RequestType{
			Id:               entry.ID,
			LatencySloTpotMs: entry.LatencySloTpotMs,
			InputSizeBucket:  entry.InputSizeBucket,
			OutputSizeBucket: entry.OutputSizeBucket,
		}
	}

	rateDistribution := make([]*pb.RateDistributionEntry, len(pythonOutput.RateDistribution))
	for i, entry := range pythonOutput.RateDistribution {
		rateDistribution[i] = &pb.RateDistributionEntry{
			RequestTypeId: entry.ID,
			Rate:          entry.Rate,
		}
	}

	fmt.Printf("Python script: Generated %d request types and %d distribution entries.\n", len(requestTypes), len(rateDistribution))
	return requestTypes, rateDistribution, nil
}

// UpdateDatasetAndRates recalculates the request distribution based on new dataset parameters.
func (h *CoreLogicHandler) UpdateDatasetAndRates(ctx context.Context, req *pb.UpdateDatasetAndRatesRequest) (*pb.UpdateDatasetAndRatesResponse, error) {
	if req == nil || len(req.GetDatasetRequests()) == 0 {
		return nil, status.Error(codes.InvalidArgument, "UpdateDatasetAndRatesRequest must contain at least one dataset_request")
	}
	for _, dr := range req.GetDatasetRequests() {
		if dr.GetDatasetName() == "" || dr.GetTokenizerName() == "" || dr.GetInputColumn() == "" || dr.GetOutputColumn() == "" {
			return nil, status.Error(codes.InvalidArgument, "Each DatasetRequest must have DatasetName, TokenizerName, InputColumn, and OutputColumn")
		}
		if dr.GetTotalRequestRate() <= 0 {
			return nil, status.Error(codes.InvalidArgument, "TotalRequestRate must be positive")
		}
		if dr.GetLatencySloTpotMs() <= 0 {
			return nil, status.Error(codes.InvalidArgument, "LatencySloTpotMs must be positive")
		}
	}

	// Generate the request types and distribution
	newRequestTypes, newDistribution, err := h.processDatasetWithPythonScript(req)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "Failed to process dataset: %v", err)
	}

	h.mu.Lock()
	defer h.mu.Unlock()

	h.currentConfig = req // Store the configuration that was used
	h.currentRequestTypes = newRequestTypes
	h.currentDistribution = newDistribution

	fmt.Printf("Dataset and rates updated. Processed %d dataset requests. Found %d total types.\n", len(req.GetDatasetRequests()), len(newRequestTypes))

	return &pb.UpdateDatasetAndRatesResponse{
		Message: "Dataset and rates updated successfully.",
	}, nil
}

// GetCurrentDistribution returns the latest calculated request types and distribution.
func (h *CoreLogicHandler) GetCurrentDistribution(ctx context.Context, req *pb.GetCurrentDistributionRequest) (*pb.GetCurrentDistributionResponse, error) {
	h.mu.RLock()
	defer h.mu.RUnlock()

	if h.currentConfig == nil {
		return nil, status.Error(codes.NotFound, "No dataset has been loaded yet. Please call UpdateDatasetAndRates first.")
	}

	// Create copies to avoid race conditions if the caller modifies the slices
	respRequestTypes := make([]*pb.RequestType, len(h.currentRequestTypes))
	copy(respRequestTypes, h.currentRequestTypes)
	respDistribution := make([]*pb.RateDistributionEntry, len(h.currentDistribution))
	copy(respDistribution, h.currentDistribution)
	respSourceRequests := make([]*pb.DatasetRequest, len(h.currentConfig.GetDatasetRequests()))
	copy(respSourceRequests, h.currentConfig.GetDatasetRequests())

	return &pb.GetCurrentDistributionResponse{
		RequestTypes:          respRequestTypes,
		RateDistribution:      respDistribution,
		SourceDatasetRequests: respSourceRequests,
	}, nil
}
