syntax = "proto3";

package profiler_service;

import "common.proto";

option go_package = "ig-wva/gen/go/profiler_service";

// Defines the set of worker and request types for which to generate a profile.
message WorkloadDefinition {
  repeated common.WorkerType worker_types = 1;
  repeated common.RequestType request_types = 2;
}

// Represents one entry in the generated performance profile.
message PerformanceProfileEntry {
  enum Status {
    STATUS_UNSPECIFIED = 0;
    OK = 1;  // Interpolation successful or exact match found.
    OK_USING_HIGHEST_RATE =
        2;              // SLO was higher than latency at highest measured rate.
    NO_DATA_FOUND = 3;  // No matching benchmarking data points found.
    SLO_UNATTAINABLE =
        4;  // SLO was lower than latency at lowest measured rate.
    INSUFFICIENT_DATA = 5;  // Only one data point found, result based on that.
    INTERNAL_ERROR = 6;     // Error during processing for this entry.
  }

  string worker_type_id = 1;   // References WorkerType.id
  string request_type_id = 2;  // References RequestType.id
  // The calculated maximum sustainable throughput (requests/second) for this
  // specific worker/request type combination while meeting the SLO.
  // Will be 0 if status indicates no data or unattainability.
  float max_throughput_rps = 3;
  // Provides context on how the throughput value was determined.
  Status status = 4;
}

// The complete performance profile generated by the service.
message PerformanceProfile {
  repeated PerformanceProfileEntry entries = 1;
}

// Request message for the GenerateProfile RPC.
// It includes the workload definition. We assume the service has a way
// to access the underlying benchmarking data (e.g., reads from Spanner/BQ).
// Alternatively, benchmarking data could be streamed or included here,
// but that might be inefficient for large datasets.
message GenerateProfileRequest {
  WorkloadDefinition workload_definition = 1;
  // Optional: Could add metadata like a job ID, priority, etc.
  // string job_id = 2;
}

// Response message for the GenerateProfile RPC.
message GenerateProfileResponse {
  PerformanceProfile performance_profile = 1;
  // Optional: Could include status, errors, metadata about the generation.
  // Status status = 2;
}

// The gRPC service definition.
service PerformanceProfileGenerator {
  // Generates a performance profile based on the provided workload definition
  // and the available benchmarking data.
  rpc GenerateProfile(GenerateProfileRequest) returns (GenerateProfileResponse);

  // Alternative: If benchmarking data is very large, consider a streaming
  // approach. rpc StreamBenchmarkingData(stream BenchmarkingDataPoint) returns
  // (stream GenerateProfileResponse); Or combine streaming input with a single
  // output: rpc GenerateProfileFromStream(stream BenchmarkingDataPoint) returns
  // (GenerateProfileResponse);
}
